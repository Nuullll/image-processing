\documentclass{article}
\renewcommand{\baselinestretch}{1.25}

\usepackage{xeCJK}  % support character

% monokai code
\usepackage{color}
\usepackage{minted}
\usemintedstyle{manni}
\setminted{
    linenos,
    fontsize=\footnotesize,
    resetmargins
}

% insert images
\usepackage{graphicx}
\graphicspath{{images/}{../images/}}
\usepackage{amsmath}
\usepackage{caption}
\numberwithin{figure}{section}
\numberwithin{table}{section}
\numberwithin{listing}{section}
\numberwithin{equation}{section}

\usepackage{subcaption}

% hyperlink
\usepackage{hyperref}
\usepackage{xcolor}
\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}

% auto newline in table
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
\usepackage{multirow}

\usepackage{mathtools}
\usepackage{amsfonts}

\author{郭一隆(2013011189)}
\title{图像处理实验报告}

\begin{document}
    \maketitle

    \tableofcontents
    \newpage

    \listoffigures
    \listoftables
    \renewcommand\listoflistingscaption{List of Source Codes}
    \listoflistings
    \newpage

    \section{原创性} % (fold)
    \label{sec:原创性}
        
        \textbf{本次图像处理大作业由本人独立思考完成，若有雷同，纯属巧合。}

    % section 原创性 (end)

    \section{基础知识} % (fold)
    \label{sec:基础知识}

        在\texttt{MATLAB}中，像素值用\texttt{uint8}类型表示，参与浮点数运算前需要转成\texttt{double}型。Section \ref{sec:基础知识} 中“测试图像”指的是\href{run:../resource/hall.mat}{\texttt{hall.mat}}中的\textbf{彩色图像}。

        \begin{enumerate}
            \item \texttt{MATLAB}提供了图像处理工具箱，在命令窗口输入\texttt{help images}可查看该工具箱内的所有函数。请阅读并大致了解这些函数的基本功能。

                \begin{table}[H]
                    \caption{图像处理工具箱函数概览(部分)}
                    \label{tab:help_images}
                    \centering
                
                    \begin{tabular}{l|l}
                    \hline
                
                    \hline
                    \textbf{函数名} & \textbf{功能} \\
                    \hline
                        \texttt{imshow} & 在\texttt{figure}中显示图像 \\
                    \hline
                        \texttt{rgb2gray} & 将彩色图像转换为灰度值图像 \\
                    \hline
                        \texttt{imwrite} & 将图像矩阵写入文件 \\
                
                    \hline
                    \end{tabular}
                \end{table}

            \item 利用\texttt{MATLAB}提供的\texttt{Image file I/O}函数分别完成以下处理：
                \begin{enumerate}
                    \item 以测试图像的中心为圆心，图像的长和宽中较小值的一半为半径画一个\textcolor{red}{红颜色}的圆；

                        \textbf{思路：}利用\texttt{meshgrid}函数生成行列索引矩阵\texttt{I, J}，将圆内部的像素点标为\textbf{逻辑1}，再利用逻辑索引将测试图像圆内的部分替换为\textcolor{red}{红色像素点}。

                        \begin{listing}[H]
                            \caption{\texttt{draw\_circle.m}}
                            \label{listing:draw_circle}
                            \inputminted{matlab}{../draw_circle.m}
                        \end{listing}

                        \begin{figure}[H]
                            \centering
                                \begin{subfigure}{0.5\textwidth}
                                    \centering
                                    \includegraphics[width=0.4\linewidth]{hall_color}
                                    \caption{处理前}
                                    \label{fig:hall_color}
                                \end{subfigure}%
                                \begin{subfigure}{0.5\textwidth}
                                    \centering
                                    \includegraphics[width=0.4\linewidth]{hall_color_red_circle}
                                    \caption{处理后}
                                    \label{fig:hall_color_red_circle}
                                \end{subfigure}

                            \caption{在大礼堂中心绘制红圆}
                            \label{fig:red_circle}
                        \end{figure}

                    \item 将测试图像涂成国际象棋状的“黑白格”的样子，其中“黑”即黑色，“白”则意味着\textbf{保留原图}。

                        \textbf{思路：}\texttt{chess\_mask}函数提供棋盘行列数接口，计算出每块的大小，同样利用\texttt{meshgrid}函数确定出\texttt{black\_mask}的位置，将图像对应位置赋为黑色。

                        \begin{listing}[H]
                            \caption{\texttt{chess\_mask.m}}
                            \label{listing:chess_mask}
                            \inputminted{matlab}{../chess_mask.m}
                        \end{listing}

                        按如下代码生成\texttt{64}格和\texttt{32}格棋盘蒙版

                        \begin{minted}{matlab}
>> imwrite(chess_mask(hall_color,8,8),'images/hall_color_masked_8_8.png')
>> imwrite(chess_mask(hall_color,4,8),'images/hall_color_masked_4_8.png')
                        \end{minted}

                        \begin{figure}[H]
                            \centering
                                \begin{subfigure}{0.5\textwidth}
                                    \centering
                                    \includegraphics[width=0.4\linewidth]{hall_color_masked_8_8}
                                    \caption{$8\times8$蒙版}
                                    \label{fig:hall_color_masked_8_8}
                                \end{subfigure}%
                                \begin{subfigure}{0.5\textwidth}
                                    \centering
                                    \includegraphics[width=0.4\linewidth]{hall_color_masked_4_8}
                                    \caption{$4\times8$蒙版}
                                    \label{fig:hall_color_masked_4_8}
                                \end{subfigure}

                            \caption{国际象棋蒙版}
                            \label{fig:chess_mask}
                        \end{figure}

                \end{enumerate}

                用看图软件浏览上述生成图片，预览效果如图\ref{fig:red_circle}和图\ref{fig:chess_mask}，达到预期效果。

        \end{enumerate}
    
    % section 基础知识 (end)

    \section{图像压缩编码} % (fold)
    \label{sec:图像压缩编码}

        \textbf{熵编码压缩比}：

        根据经验，对于文本文件，重复性越高，则压缩比越高，测试如下表

        \begin{table}[H]
            \caption{WinRar压缩文本文件}
            \label{tab:winrar}
            \centering
        
            \ttfamily
            \begin{tabular}{l|l|l|l|l}
            \hline
        
            \hline
            \textbf{文件名} & \textbf{文本内容(matlab写入文件)} & \textbf{压缩前大小} & \textbf{压缩后大小} & \textbf{压缩比} \\
            \hline
                high.txt & repmat(['1'],1,10000) & 10000bytes & 101bytes & 99.01 \\
            \hline
                normal.txt & int2str(2\^{}1000) & 302bytes & 106bytes & 2.85 \\
            \hline
                low.txt & 'ghjkl;' & 6bytes & 77bytes & 0.08 \\
        
            \hline
            \end{tabular}
        \end{table}

        本章练习题所用数据均可由“JpegCoeff.mat”导入，其内容如表\ref{tab:JpegCoeff}所示。本章练习题中“测试图像”指的是\href{run:../resource/hall.mat}{\texttt{hall.mat}}中的\textbf{灰度图像}。

        \begin{table}[H]
            \caption{\texttt{JpegCoeff.mat}中所含数据}
            \label{tab:JpegCoeff}
            \centering
        
            \begin{tabular}{ccc}
            \hline
        
            \hline
            \textbf{变量名} & \textbf{含义} & \textbf{说明} \\
            \hline
                \texttt{QTAB} & \tabincell{l}{\texttt{DCT}系数的量化 \\步长矩阵，式(\ref{eq:QTAB})} & \\
            \hline
                \texttt{DCTAB} & \tabincell{l}{\texttt{DC}系数预测误差 \\的\texttt{Category}码本，\\表\ref{tab:DC_Huffman}} & \tabincell{l}{每行对应一个\texttt{Category}，第一列对应\texttt{Huffman}编码 \\的长度\texttt{L}，随后\texttt{L}列对应该码字，再后全零为填充物} \\
            \hline
                \texttt{ACTAB} & \tabincell{l}{\texttt{AC}系数的 (\texttt{Run/Size})\\的码本，完整的表\ref{tab:AC_Huffman}} & \tabincell{l}{每行对应一个(\texttt{Run/Size})，第一列表示\texttt{Run}，第二列 \\表示\texttt{Size}，第三列表示该(\texttt{Run/Size})对应的\texttt{Huffman} \\编码的长度\texttt{L}，随后\texttt{L}列对应该码字，再后全零为填充物} \\
            \hline

            \hline
            \end{tabular}
        \end{table}

        \begin{equation}
        \label{eq:QTAB}
            Q = \left[
            \begin{matrix}
                16 & 11 & 10 & 16 & 24 & 40 & 51 & 61 \\
                12 & 12 & 14 & 19 & 26 & 58 & 60 & 55 \\
                14 & 13 & 16 & 24 & 40 & 57 & 69 & 56 \\
                14 & 17 & 22 & 29 & 51 & 87 & 80 & 62 \\
                18 & 22 & 37 & 56 & 68 & 109 & 103 & 77 \\
                24 & 35 & 55 & 64 & 81 & 104 & 113 & 92 \\
                49 & 64 & 78 & 87 & 103 & 121 & 120 & 101 \\
                72 & 92 & 95 & 98 & 112 & 100 & 103 & 99
            \end{matrix}
            \right]
        \end{equation}

        \begin{table}[H]
            \caption{亮度直流分量预测误差的\texttt{Category}及其\texttt{Huffman}编码}
            \label{tab:DC_Huffman}
            \centering
        
            \begin{tabular}{ccc}
            \hline
        
            \hline
            \textbf{预测误差} & \textbf{\texttt{Category}} & \textbf{\texttt{Huffman}编码} \\
            \hline
                0 & 0 & 00 \\
                -1, 1 & 1 & 010 \\
                -3, -2, 2, 3 & 2 & 011 \\
                -7, $\cdots$, -4, 4, $\cdots$, 7 & 3 & 100 \\
                -15, $\cdots$, -8, 8, $\cdots$, 15 & 4 & 101 \\
                -31, $\cdots$, -16, 16, $\cdots$, 31 & 5 & 110 \\
                -63, $\cdots$, -32, 32, $\cdots$, 63 & 6 & 1110 \\
                -127, $\cdots$, -64, 64, $\cdots$, 127 & 7 & 11110 \\
                -255, $\cdots$, -128, 128, $\cdots$, 255 & 8 & 111110 \\
                -511, $\cdots$, -256, 256, $\cdots$, 511 & 9 & 1111110 \\
                -1023, $\cdots$, -512, 512, $\cdots$, 1023 & 10 & 11111110 \\
                -2047, $\cdots$, -1024, 1024, $\cdots$, 2047 & 11 & 111111110 \\
            \hline

            \hline
            \end{tabular}
        \end{table}

        \begin{table}[H]
            \caption{亮度\texttt{AC}分量的\texttt{Run/Size}及其\texttt{Huffman}编码(部分)}
            \label{tab:AC_Huffman}
            \centering
        
            \begin{tabular}{llllll}
            \hline
        
            \hline
            \textbf{\texttt{Run/Size}} & \textbf{码长} & \textbf{码字} & \textbf{\texttt{Run/Size}} & \textbf{码长} & \textbf{码字} \\
            \hline
                0/0(EOB) & 4 & 1010 & & & \\
                0/1 & 2 & 00 & 4/1 & 6 & 111011 \\
                0/2 & 2 & 01 & 4/2 & 10 & 1111111000 \\
                0/3 & 3 & 100 & 4/3 & 16 & 1111111110010111 \\
                0/4 & 4 & 1011 & 4/4 & 16 & 1111111110011000 \\
                0/5 & 5 & 11010 & 4/5 & 16 & 1111111110011001 \\
                0/6 & 6 & 111000 & 4/6 & 16 & 1111111110011010 \\
                0/7 & 7 & 1111000 & 4/7 & 16 & 1111111110011011 \\
                0/8 & 10 & 1111110110 & 4/8 & 16 & 1111111110011100 \\
                0/9 & 16 & 1111111110000010 & 4/9 & 16 & 1111111110011101 \\
                0/A & 16 & 1111111110000011 & 4/A & 16 & 1111111110011110 \\
                 & & & & & \\
                1/1 & 4 & 1100 & 8/1 & 8 & 11111010 \\
                1/2 & 6 & 111001 & 8/2 & 15 & 111111111000000 \\
                1/3 & 7 & 1111001 & 8/3 & 16 & 1111111110110111 \\
                1/4 & 9 & 111110110 & 8/4 & 16 & 1111111110111000 \\
                1/5 & 11 & 11111110110 & 8/5 & 16 & 1111111110111001 \\
                1/6 & 16 & 1111111110000100 & 8/6 & 16 & 1111111110111010 \\
                1/7 & 16 & 1111111110000101 & 8/7 & 16 & 1111111110111011 \\
                1/8 & 16 & 1111111110000110 & 8/8 & 16 & 1111111110111100 \\
                1/9 & 16 & 1111111110000111 & 8/9 & 16 & 1111111110111101 \\
                1/A & 16 & 1111111110001000 & 8/A & 16 & 1111111110111110 \\
                 & & & F/0(ZRL) & 11 & 11111111001 \\
                2/1 & 5 & 11011 & F/1 & 16 & 1111111111110101 \\
                2/2 & 8 & 11111000 & F/2 & 16 & 1111111111110110 \\
                2/3 & 10 & 1111110111 & F/3 & 16 & 1111111111110111 \\
                2/4 & 16 & 1111111110001001 & F/4 & 16 & 1111111111111000 \\
                2/5 & 16 & 1111111110001010 & F/5 & 16 & 1111111111111001 \\
                2/6 & 16 & 1111111110001011 & F/6 & 16 & 1111111111111010 \\
                2/7 & 16 & 1111111110001100 & F/7 & 16 & 1111111111111011 \\
                2/8 & 16 & 1111111110001101 & F/8 & 16 & 1111111111111100 \\
                2/9 & 16 & 1111111110001110 & F/9 & 16 & 1111111111111101 \\
                2/A & 16 & 1111111110001111 & F/A & 16 & 1111111111111110 \\
            \hline
        
            \hline
            \end{tabular}
        \end{table}

        \begin{enumerate}
            \item 图像的预处理是将每个像素灰度值减去\texttt{128}，这个步骤是否可以在变换域进行？

                变换域与时域(或空域)的对应关系为
                \begin{equation}
                    \mathbf{C}=\sum_{x=0}^{N-1}\sum_{y=0}^{N-1}P_{x,y}\mathbf{D}^{(2)}(x,y)
                \end{equation}
                其中$\mathbf{D}^{(2)}(x,y)$表示二维\texttt{DCT}的第$(x,y)$个基矩阵，其第$(i,j)$个分量为
                \begin{equation}
                    \mathbf{D}_{i,j}^{(2)}(x,y)=\alpha _i\alpha _j\cos{\frac{i(2x+1)\pi}{2N}}\cos{\frac{j(2y+1)\pi}{2N}}
                \end{equation}

                对原图像进行预处理：
                $$\bar{P}_{x,y}=P_{x,y}-128$$

                则有
                \[
                    \begin{split}
                        \bar{\mathbf{C}} & =\sum_{x=0}^{N-1}\sum_{y=0}^{N-1}\bar{P}_{x,y}\mathbf{D}^{(2)}(x,y) \\
                         & =\mathbf{C}-128\sum_{x=0}^{N-1}\sum_{y=0}^{N-1}\mathbf{D}^{(2)}(x,y)
                    \end{split}
                \]

                而
                \[
                    \begin{split}
                        \sum_{x=0}^{N-1} \sum_{y=0}^{N-1} \mathbf{D}_{i,j}^{(2)}(x,y) &= \alpha _i \alpha _j \sum_{x=0}^{N-1} \cos{\frac{i(2x+1)\pi}{2N}} \sum_{y=0}^{N-1} \cos{\frac{j(2y+1)\pi}{2N}}\\
                        &= \left\{
                            \begin{matrix}
                                \alpha _i \alpha _j N^2 = N, & i=j=0\\
                                0, & elsewhere\\
                            \end{matrix}
                        \right.
                    \end{split}
                \]

                若要在\textbf{变换域}进行预处理，则对应关系为
                \[
                    \begin{split}
                        \bar{\mathbf{C}}_{i,j} &= \mathbf{C}_{i,j} - 128N, i=j=0\\
                        \bar{\mathbf{C}}_{i,j} &= \mathbf{C}_{i,j}, \qquad \quad \ \ elsewhere
                    \end{split}
                \]

                \textbf{因此，这个步骤可以在变换域进行，只需把变换域直流分量减去$128N$即可}，取\texttt{hall\_gray}左上角$8\times 8$验证如下：

                \begin{minted}{matlab}
>> A = hall_gray(1:8,1:8);
>> Y1 = dct2(A-128);    % preprocess on Space Domain
>> Y2 = dct2(A);
>> Y2(1,1) = Y2(1,1) - 128*8;   % preprocess on Transform Domain
>> mse(Y1,Y2)

ans =

   5.5804e-27
                \end{minted}

                其中\texttt{mse}为自定义函数，用于计算两个矩阵的均方误差：

                \begin{listing}[H]
                    \caption{\texttt{mse.m}}
                    \label{code:mse}
                    \inputminted{matlab}{../mse.m}
                \end{listing}

                由运行代码中得到的\texttt{mse}结果可知，在变换域减去一定直流分量与预处理原图像是\textbf{等价}的。

            \item 根据下式\ref{eq:dct2}自行编程实现二维\texttt{DCT}：

                \begin{equation}
                    \label{eq:dct2}
                    \mathbf{C} = \mathbf{DPD}^T
                \end{equation}

                其中

                \[
                    \mathbf{D} = \sqrt{\frac{2}{N}} \begin{bmatrix}
                        \sqrt{\frac{1}{2}} & \sqrt{\frac{1}{2}} & \cdots & \sqrt{\frac{1}{2}} \\
                        \cos{\frac{\pi}{2N}} & \cos{\frac{3\pi}{2N}} & \cdots & \cos{\frac{(2N-1)\pi}{2N}} \\
                        \vdots & \vdots & \ddots & \vdots \\
                        \cos{\frac{(N-1)\pi}{2N}} & \cos{\frac{(N-1)3\pi}{2N}} & \cdots & \cos{\frac{(N-1)(2N-1)\pi}{2N}}
                    \end{bmatrix}
                \]

                \begin{listing}[H]
                    \caption{\texttt{mydct2.m}}
                    \label{code:mydct2}
                    \inputminted{matlab}{../mydct2.m}
                \end{listing}

                仍取左上角$8\times 8$色块进行测试：
                \begin{minted}{matlab}
>> A = hall_gray(1:8,1:8);
>> mse(mydct2(A),dct2(A))

ans =

   2.6817e-26
                \end{minted}

                说明\texttt{mydct2}与\texttt{dct2}计算结果相同。

            \item 如果将\texttt{DCT}系数矩阵中右侧四列(或左侧四列)的系数全部置零，逆变换后的图像会发生什么变化？

                \texttt{DCT}矩阵的右侧主要是横向高频分量系数，即影响横向纹理的清晰度，\textbf{右侧四列置零会使得横向纹理变模糊}；左侧四列包含了左上角的全部低频分量，以及左下角的纵向高频分量，\textbf{左侧四列置零会使得整个图像变黑，无法辨认，仅残留少量横向纹理}。

                为了便于图像处理，自定义函数\texttt{imdct}以及\texttt{imidct}，实现分块($8\times 8$)应用\texttt{DCT}或\texttt{IDCT}并进行整合的功能，\texttt{imdct}接受\textbf{函数句柄}作为参数，方便后续的各种处理方式。

                \begin{listing}[H]
                    \caption{\texttt{imdct.m}}
                    \label{code:imdct}
                    \inputminted{matlab}{../imdct.m}
                \end{listing}

                \begin{listing}[H]
                    \caption{\texttt{imidct.m}}
                    \label{code:imidct}
                    \inputminted{matlab}{../imidct.m}
                \end{listing}

                \newpage
                选取一小块$8\times 8$图像验证：
                \begin{minted}{matlab}
    >> rightzero = @(A)([A(:,1:4),zeros(8,4)]);     % Handle of process function
    >> A = hall_gray(97:104,153:160);
    >> I = imidct(imdct(A,rightzero));
    >> imwrite(A,'images\test_block.png');
    >> imwrite(I,'images\test_block_rightzero.png');
    >>
    >> leftzero = @(A)([zeros(8,4),A(:,5:8)]);
    >> I = imidct(imdct(A,leftzero));
    >> imwrite(I,'images\test_block_leftzero.png');
                \end{minted}

                \begin{figure}[H]
                    \centering
                    \begin{subfigure}{0.3\textwidth}
                        \centering
                        \includegraphics[width=0.6\linewidth]{test_block}
                        \caption{测试\texttt{block}}
                    \end{subfigure}%
                    \begin{subfigure}{0.3\textwidth}
                        \centering
                        \includegraphics[width=0.6\linewidth]{test_block_rightzero}
                        \caption{右四列置零}
                    \end{subfigure}%
                    \begin{subfigure}{0.3\textwidth}
                        \centering
                        \includegraphics[width=0.6\linewidth]{test_block_leftzero}
                        \caption{左四列置零}
                    \end{subfigure}
                    \caption{左右置零-小块图像测试结果}
                \end{figure}

                再测试整体效果：

                \begin{minted}{matlab}
    >> imwrite(hall_gray,'images\hall_gray.png');
    >> I = imidct(imdct(hall_gray,rightzero));
    >> imwrite(I,'images\hall_gray_rightzero.png');
    >> I = imidct(imdct(hall_gray,leftzero));
    >> imwrite(I,'images\hall_gray_leftzero.png');
                \end{minted}

                图像处理结果如图\ref{fig:rlzero}，可见\textbf{右四列置零后横向纹理变弱(树的部分较明显)，左四列置零后仅剩余少量横向高频分量(轮廓)，符合预期。}

                \begin{figure}[H]
                    \centering
                    \begin{subfigure}{\textwidth}
                        \centering
                        \includegraphics[width=0.6\linewidth]{hall_gray}
                        \caption{\texttt{hall\_gray}}
                    \end{subfigure}
                    \begin{subfigure}{\textwidth}
                        \centering
                        \includegraphics[width=0.6\linewidth]{hall_gray_rightzero}
                        \caption{右四列置零}
                    \end{subfigure}
                    \begin{subfigure}{\textwidth}
                        \centering
                        \includegraphics[width=0.6\linewidth]{hall_gray_leftzero}
                        \caption{左四列置零}
                    \end{subfigure}
                    \caption{左右置零-整体图像测试结果}
                    \label{fig:rlzero}
                \end{figure}

            \item 若对\texttt{DCT}系数分别做转置、旋转\texttt{90}度和旋转\texttt{180}度操作，逆变换后恢复的图像有何变化？

                \begin{itemize}
                    \item \textbf{转置}使得行列频率信息交换，则逆变换后\textbf{图像被转置}

                        \[
                            \mathbf{C}^T = (\mathbf{DPD}^T)^T = \mathbf{DP}^T\mathbf{D}^T
                        \]

                        \begin{minted}{matlab}
>> A = hall_gray(97:104,153:160);
>> transpose = @(A)(A.');
>> I = imidct(imdct(A,transpose));
>> imwrite(I,'images\test_block_transpose.png');
                        \end{minted}

                        \begin{figure}[H]
                            \centering
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{test_block}
                                \caption{\texttt{test\_block}}
                            \end{subfigure}%
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{test_block_transpose}
                                \caption{转置}
                            \end{subfigure}
                            \caption{转置\texttt{DCT}系数}
                        \end{figure}

                    \item \textbf{旋转\texttt{90}度}使得直流分量系数变为纵向高频分量系数，则逆变换后\textbf{整体图像变暗，纵向高频分量强烈}

                        \begin{minted}{matlab}
>> I = imidct(imdct(A,@rot90));
>> imwrite(I,'images\test_block_rot90.png');
>> 
>> I = imidct(imdct(hall_gray,@rot90));
>> imwrite(I,'images\hall_gray_rot90.png');
                        \end{minted}

                        \begin{figure}[H]
                            \centering
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{test_block}
                                \caption{\texttt{test\_block}}
                            \end{subfigure}%
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{test_block_rot90}
                                \caption{逆时针旋转\texttt{90}度}
                            \end{subfigure}
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{hall_gray}
                                \caption{\texttt{hall\_gray}}
                            \end{subfigure}%
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{hall_gray_rot90}
                                \caption{逆时针旋转\texttt{90}度}
                            \end{subfigure}
                            \caption{\texttt{DCT}系数逆时针旋转\texttt{90}度}
                        \end{figure}

                        纵向高频分量过强导致了明显的黑白分层，原有图像轮廓还能分辨，细节很难辨认。

                    \item \textbf{旋转\texttt{180}度}使得直流分量系数变为横纵高频分量系数，则逆变换后\textbf{整体图像变暗，横纵高频分量均变强}

                        \begin{minted}{matlab}
>> rot180 = @(A)(rot90(A,2));
>> I = imidct(imdct(A,rot180));
>> imwrite(I,'images\test_block_rot180.png');
>> 
>> I = imidct(imdct(hall_gray,rot180));
>> imwrite(I,'images\hall_gray_rot180.png');
                        \end{minted}

                        \begin{figure}[H]
                            \centering
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{test_block}
                                \caption{\texttt{test\_block}}
                            \end{subfigure}%
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{test_block_rot180}
                                \caption{旋转\texttt{180}度}
                            \end{subfigure}
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{hall_gray}
                                \caption{\texttt{hall\_gray}}
                            \end{subfigure}%
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{hall_gray_rot180}
                                \caption{旋转\texttt{180}度}
                            \end{subfigure}
                            \caption{\texttt{DCT}系数旋转\texttt{180}度}
                        \end{figure}

                        强烈的横纵高频分量导致了明显的黑白分块，原有图像轮廓能凭借先验知识分辨，细节很难辨认。

                \end{itemize}

            \item 如果认为差分编码是一个系统，请绘出这个系统的频率响应，说明其滤波器类型。\texttt{DC}系数先进行差分编码再进行熵编码，说明\texttt{DC}系数的哪种分量更多？

                差分编码系统：

                \[
                    \hat{c}_D(n) = \left\{ \begin{matrix*}[l]
                        \tilde{c}_D(n) & n = 1 \\
                        \tilde{c}_D(n-1) - \tilde{c}_D(n) & elsewhere \\
                    \end{matrix*}
                    \right.
                \]

                不妨认为$\tilde{c}_D(n)$是因果信号，则差分编码系统传递函数为

                $$
                    H(z) = z^{-1} - 1
                $$

                是\textbf{高通滤波器}，幅频特性如图\ref{fig:freqz_differential_coding}

                这说明\texttt{DC}系数中的\textbf{低频分量更多}，通过差分编码滤去大量低频分量再进行熵编码，码长缩短。直观地说，\texttt{DC}系数中相邻系数一般相差不大，差分后压缩性能更佳。

                \begin{figure}[H]
                    \centering
                    \includegraphics[width=\textwidth]{freqz_differential_coding}
                    \caption{差分编码系统幅频特性}
                    \label{fig:freqz_differential_coding}
                \end{figure}

            \item \texttt{DC}预测误差的取值和\texttt{Category}值有何关系？如何利用预测误差计算出其\texttt{Category}？

                观察表\ref{tab:DC_Huffman}容易得出：(预测误差记为\texttt{Error})

                $$
                    Error \in \{ 2^{Category-1} \leq \left| n\right| < 2^{Category} \mid n \in \mathbb{Z} \}
                $$

                $$
                    Category = \left \lceil \log_2{\left| Error \right| + 1} \right \rceil
                $$

            \item 实现\texttt{Zig-Zag}扫描

                \begin{figure}[H]
                    \centering
                    \includegraphics[width=0.5\textwidth]{Zig-Zag}
                    \caption{\texttt{Zig-Zag}扫描示意图}
                    \label{fig:zig_zag}
                \end{figure}

                \begin{enumerate}
                    \item 循环实现
                        \inputminted{matlab}{../zigzag1.m}
                        \begingroup
                            \captionof{listing}{\texttt{zigzag1.m}}
                        \endgroup

                    \item 查表实现：扫描固定$8\times 8$大小的矩阵可直接用查表法实现

                        \begin{listing}[H]
                            \caption{\texttt{zigzag2.m}}
                            \inputminted{matlab}{../zigzag2.m}
                        \end{listing}

                \end{enumerate}

                能想到的只有通用但低效的循环算法以及专用高效的查表法，在当前给定条件下，显然查表法更具有优势。

            \item 对测试图像分块、\texttt{DCT}和量化，将量化后的系数写成矩阵的形式，其中每一列为一个块的\texttt{DCT}系数\texttt{Zig-Zag}扫描后形成的列矢量，第一行为各个块的\texttt{DC}系数。

                先延伸图像使得其宽高像素值均为\texttt{8}的倍数，再分块、\texttt{DCT}、量化、\texttt{Zig-Zag}扫描，最后进行整合。

                \inputminted{matlab}{../quantize.m}
                \begingroup
                    \captionof{listing}{\texttt{quantize.m}}
                \endgroup

            \item 实现本章介绍的\texttt{JPEG}编码，输出为\texttt{DC}系数的码流、\texttt{AC}系数的码流、图像高度和图像宽度，写入\href{run:../result/jpegcodes.mat}{\texttt{jpegcodes.mat}}文件。

                \inputminted{matlab}{../jpeg.m}
                \begingroup
                    \captionof{listing}{\texttt{jpeg.m}}
                \endgroup

            \item 计算压缩比(输入文件长度/输出码流长度)，注意转换为相同进制。

                压缩比$=\frac{height\times width\times 8}{length(DC\_stream) + length(AC\_stream)}=\frac{120\times168\times 8}{2031+23072}=6.42$

            \item 请实现本章介绍的\texttt{JPEG}解码。

                \textbf{思路：}

                \begin{enumerate}
                    \item 解\texttt{DC}码流：利用\texttt{DCTAB}逐行匹配得到\texttt{magnitude}码长，进一步解出系数；
                    \item 解\texttt{AC}码流：利用\texttt{ACTAB}逐行匹配得到\texttt{Run}、\texttt{Size}，注意\texttt{EOB}和\texttt{ZRL}需特殊处理，进一步解出系数；
                    \item 逆\texttt{Zig-Zag}：查表法；
                    \item 反量化；
                    \item 按块逆\texttt{DCT}变换；
                    \item 拼接，\texttt{+128}；
                    \item 裁剪图像使得与原图像宽高相同。
                \end{enumerate}

                \inputminted{matlab}{../dejpeg.m}
                \begingroup
                    \captionof{listing}{\texttt{dejpeg.m}}
                \endgroup

                \textbf{编解码效果：}

                \begin{enumerate}
                    \item \texttt{PSNR}评价：
                        \begin{minted}{matlab}
>> jpeg(hall_gray,QTAB,DCTAB,ACTAB);
>> load('result\jpegcodes.mat')
>> image = dejpeg(DC_stream,AC_stream,height,width,QTAB,DCTAB,ACTAB);
>> psnr = 10*log10(255^2/mse(image,hall_gray))

psnr =

   34.8926
                        \end{minted}

                        $\textrm{PSNR}=34.89\textrm{dB}$说明失真较小，编解码效果很好。

                    \item 主观评价：
                        \begin{figure}[H]
                            \centering
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{hall_gray}
                                \caption{原图：\texttt{hall\_gray}}
                            \end{subfigure}%
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{hall_gray_dejpeg}
                                \caption{编解码后：\texttt{hall\_gray\_dejpeg}}
                            \end{subfigure}
                            \caption{主观评价编解码效果}
                        \end{figure}

                        肉眼几乎无法分辨编解码后图像与原图的区别，而压缩比达到了\texttt{6.42}，这说明\texttt{JPEG}编码是十分有效的图像压缩编码。

                \end{enumerate}

            \item 将量化步长减小为原来的一半，重做编解码。

                \begin{minted}{matlab}
>> jpeg(hall_gray,QTAB/2,DCTAB,ACTAB);
>> load('result\jpegcodes.mat')
>> image = dejpeg(DC_stream,AC_stream,height,width,QTAB/2,DCTAB,ACTAB);
>> psnr = 10*log10(255^2/mse(image,hall_gray))

psnr =

    37.3208
                \end{minted}

                而可求得压缩比$=4.41$。

                由此可知，减小量化步长可进一步减小失真率，但也伴随着压缩比的迅速衰减。而标准量化步长可较好地兼顾图像质量与压缩比。

            \item 看电视时偶尔能看到美丽的雪花图像(\href{../resource/snow.mat}{\texttt{snow.mat}})，对其进行编解码。

                \textbf{预测：}\texttt{JPEG}编码利用了自然图像通常高频分量较少的特点，而美丽的雪花图像高频分量非常强(横纵方向黑白相间)，可以预见\textbf{压缩比将大打折扣}。高频分量量化步长较大会导致\textbf{失真率升高}。

                \begin{minted}{matlab}
>> [DC_stream,AC_stream,height,width] = jpeg(snow,QTAB,DCTAB,ACTAB);
>> image = dejpeg(DC_stream,AC_stream,height,width,QTAB,DCTAB,ACTAB);
>> psnr = 10*log10(255^2/mse(image,snow))

psnr =

   29.5614

>> r = height*width*8/length([DC_stream,AC_stream])

r =

    3.6450
                \end{minted}

                结果符合预期，原因在预测部分已说明。

                \begin{figure}[H]
                    \centering
                    \begin{subfigure}{0.5\textwidth}
                        \centering
                        \includegraphics[width=0.6\linewidth]{snow}
                        \caption{原图：\texttt{snow}}
                    \end{subfigure}%
                    \begin{subfigure}{0.5\textwidth}
                        \centering
                        \includegraphics[width=0.6\linewidth]{snow_dejpeg}
                        \caption{编解码后：\texttt{snow\_dejpeg}}
                    \end{subfigure}
                    \caption{美丽的雪花图像编解码效果}
                \end{figure}

        \end{enumerate}
    
    % section 图像压缩编码 (end)

    \newpage
    \section{信息隐藏} % (fold)
    \label{sec:信息隐藏}
    
        \begin{enumerate}
            \item 实现本章介绍的空域隐藏方法和提取方法。验证其抗\texttt{JPEG}编码能力。

                \textbf{隐藏信息：}\textcolor{green}{\texttt{Ingress Enlightened Agent @Vone}}

                \begin{listing}[H]
                    \inputminted{matlab}{../hide.m}
                    \caption{\texttt{hide.m}}
                \end{listing}

                \begin{listing}[H]
                    \inputminted{matlab}{../extract.m}
                    \caption{\texttt{extract.m}}
                \end{listing}

                能够正确提取信息：

                \begin{minted}{matlab}
>> str = 'Ingress Enlightened Agent @Vone';
>> 
>> A = hide(hall_color,str);   % hide(hall_gray,str) also works
>> extract(A)

ans =

Ingress Enlightened Agent @Vone 
                \end{minted}

                若不进行压缩编码，隐藏信息后的图像与原图几乎完全相同。

                \begin{figure}[H]
                    \centering
                    \begin{subfigure}{0.5\textwidth}
                        \centering
                        \includegraphics[width=0.6\linewidth]{hall_color}
                        \caption{原图：\texttt{hall\_color}}
                    \end{subfigure}%
                    \begin{subfigure}{0.5\textwidth}
                        \centering
                        \includegraphics[width=0.6\linewidth]{hall_color_hide}
                        \caption{隐藏信息后：\texttt{hall\_color\_hide}}
                    \end{subfigure}
                    \caption{空域隐藏信息对图像的影响}
                \end{figure}

                \textbf{空域隐藏的抗\texttt{JPEG}编码能力：}

                \begin{minted}{matlab}
>> A = hide(hall_gray,str);
>> [DC_stream,AC_stream,height,width] = jpeg(A,QTAB,DCTAB,ACTAB);
>> image = dejpeg(DC_stream,AC_stream,height,width,QTAB,DCTAB,ACTAB);
>> extract(image)

ans =

fvÒ½<×fß}ïºßËk2Â<-ç0®a2fØ( 
                \end{minted}

                就测试信息而言，可以说\textbf{空域隐藏方法抗\texttt{JPEG}编码能力极弱}。

            \item 依次实现本章介绍的三种变换域信息隐藏方法和提取方法，分析嵌密方法的隐蔽性以及嵌密后\texttt{JPEG}图像的质量变化和压缩比变化。

                在\href{../jpeg.m}{\texttt{jpeg.m}}的基础上完成\href{../jpeg_hide.m}{\texttt{jpeg\_hide.m}}，增加\texttt{hidefun}以及\texttt{hideinfo}接口。

                \begin{listing}[H]
                    \inputminted[firstline=1, lastline=8]{matlab}{../jpeg_hide.m}
                    \caption{\texttt{jpeg\_hide.m(1-8)}}
                \end{listing}

                \begin{listing}[H]
                    \inputminted[firstline=1, lastline=12]{matlab}{../dejpeg_extract.m}
                    \caption{\texttt{dejpeg\_extract.m(1-12)}}
                \end{listing}

                \begin{enumerate}
                    \item 同空域方法，用信息位逐一替换掉\textbf{每个}量化后的\texttt{DCT}系数的最低位，再进行熵编码。

                        由于\texttt{DCT}系数可能是\textbf{负数}，若将系数转为二进制再替换最低位会涉及到补码等问题，比较繁琐，可直接从\textbf{奇偶性}考虑，比如奇数代表\texttt{1}，偶数代表\texttt{0}。

                        \textbf{隐藏函数：}
                        \inputminted{matlab}{../hide1.m}
                        \begingroup
                            \captionof{listing}{\texttt{hide1.m}}
                        \endgroup

                        \textbf{提取函数：}
                        \begin{listing}[H]
                            \inputminted{matlab}{../extract1.m}
                            \caption{\texttt{extract1.m}}
                        \end{listing}

                        测试结果：

                        \begin{minted}{matlab}
>> [DC_stream,AC_stream,height,width] = jpeg_hide(hall_gray,QTAB,DCTAB,ACTAB,@hide1,str);
>> [image,info] = dejpeg_extract(DC_stream,AC_stream,height,width,QTAB,DCTAB,ACTAB,@extract1);
>> info

info =

Ingress Enlightened Agent @Vone 
                        \end{minted}

                        \begin{figure}[H]
                            \centering
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{hall_gray_dejpeg}
                                \caption{未隐藏信息：\texttt{hall\_gray\_dejpeg}}
                            \end{subfigure}%
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{hall_gray_hide1}
                                \caption{隐藏信息：\texttt{hall\_gray\_hide1}}
                            \end{subfigure}
                            \caption{\texttt{DCT}域隐藏方法\texttt{1}对图像的影响}
                        \end{figure}

                        可准确无误地提取出隐藏信息，但是隐藏信息再解码后，可明显看出隐藏信息的图像块(左上角)出现了失真。\textbf{隐蔽性较差}，肉眼可察觉。

                        $$\textrm{PSNR}=34.69\textrm{dB}, r=6.32$$

                        (隐藏信息较少，因此\texttt{PSNR}和\texttt{r}减小幅度较小)

                    \item 用信息位逐一替换掉\textbf{若干}量化后的\texttt{DCT}系数的最低位，再进行熵编码。

                        利用\texttt{magic}函数生成具体替换哪些\texttt{DCT}系数。

                        \textbf{隐藏函数：}
                        \begin{listing}[H]
                            \inputminted{matlab}{../hide2.m}
                            \caption{\texttt{hide2.m}}
                        \end{listing}

                        \textbf{提取函数：}
                        \inputminted{matlab}{../extract2.m}
                        \begingroup
                            \captionof{listing}{\texttt{extract2.m}}
                        \endgroup

                        测试结果：

                        \begin{minted}{matlab}
>> [DC_stream,AC_stream,height,width] = jpeg_hide(hall_gray,QTAB,DCTAB,ACTAB,@hide2,str);
>> [image,info] = dejpeg_extract(DC_stream,AC_stream,height,width,QTAB,DCTAB,ACTAB,@extract2);
>> info

info =

Ingress Enlightened Agent @Vone 
                        \end{minted}

                        \begin{figure}[H]
                            \centering
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{hall_gray_dejpeg}
                                \caption{未隐藏信息：\texttt{hall\_gray\_dejpeg}}
                            \end{subfigure}%
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{hall_gray_hide2}
                                \caption{隐藏信息：\texttt{hall\_gray\_hide2}}
                            \end{subfigure}
                            \caption{\texttt{DCT}域隐藏方法\texttt{2}对图像的影响}
                        \end{figure}

                        可准确无误地提取出隐藏信息，由于分散地替换了\texttt{DCT}系数，因此不像上一种方法一样存在密集的失真现象，但仔细观察仍可发现部分色块的失真。\textbf{隐蔽性稍好}，但仍容易发现。

                        \textbf{若不知道隐藏信息具体藏在哪些\texttt{DCT}系数的最低位(这里采用\texttt{magic}函数加密)，仍然很难提取出信息。}

                        $$\textrm{PSNR}=34.20\textrm{dB}, r=6.27$$

                    \item 先将待隐藏信息用\texttt{1,-1}的序列表示，再逐一将信息位追加在每个块\texttt{Zig-Zag}顺序的最后一个非零\texttt{DCT}系数之后；如果原本该图像块的最后一个系数就不为零，那就用信息位替换该函数。

                        \textbf{隐藏函数：}
                        \begin{listing}[H]
                            \inputminted{matlab}{../hide3.m}
                            \caption{\texttt{hide3.m}}
                        \end{listing}

                        \textbf{提取函数：}
                        \inputminted{matlab}{../extract3.m}
                        \begingroup
                            \captionof{listing}{\texttt{extract3.m}}
                        \endgroup

                        测试结果：

                        \begin{minted}{matlab}
>> [DC_stream,AC_stream,height,width] = jpeg_hide(hall_gray,QTAB,DCTAB,ACTAB,@hide3,str);
>> [image,info] = dejpeg_extract(DC_stream,AC_stream,height,width,QTAB,DCTAB,ACTAB,@extract3);
>> info

info =

Ingress Enlightened Agent @Vone 
                        \end{minted}

                        \begin{figure}[H]
                            \centering
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{hall_gray_dejpeg}
                                \caption{未隐藏信息：\texttt{hall\_gray\_dejpeg}}
                            \end{subfigure}%
                            \begin{subfigure}{0.5\textwidth}
                                \centering
                                \includegraphics[width=0.6\linewidth]{hall_gray_hide3}
                                \caption{隐藏信息：\texttt{hall\_gray\_hide3}}
                            \end{subfigure}
                            \caption{\texttt{DCT}域隐藏方法\texttt{3}对图像的影响}
                        \end{figure}

                        可准确无误地提取出隐藏信息，隐藏信息与未隐藏信息的图像肉眼无法分辨出区别，\textbf{隐蔽性较好}。

                        $$\textrm{PSNR}=33.66\textrm{dB}, r=6.23$$

                \end{enumerate}

                \begin{table}[H]
                    \caption{三种\texttt{DCT}域隐藏方法对比}
                    \centering
                
                    \begin{tabular}{|c|c|c|c|c|}
                    \hline
                
                    \hline
                    \textbf{隐藏算法} & \textbf{隐蔽性} & \textbf{\texttt{PSNR}(dB)} & \textbf{压缩比} & \textbf{信息容纳上限(\texttt{bits})} \\
                    \hline
                        不隐藏 & - & 34.89 & 6.42 & - \\
                    \hline
                        \texttt{hide1} & 差 & 34.69 & 6.32 & \texttt{height*width} \\
                    \hline
                        \texttt{hide1}(接近饱和) & 极差 & 29.62 & 3.55 & \texttt{height*width} \\
                    \hline
                        \texttt{hide2} & 中等 & 34.20 & 6.27 & 平均值：\texttt{height*width/50} \\
                    \hline
                        \texttt{hide3} & 较好 & 33.66 & 6.23 & \texttt{height*width/64} \\
                    \hline

                    \hline
                    \end{tabular}
                \end{table}

                其中上表中\texttt{hide1,hide2,hide3}隐藏的信息均为单一字符串，\texttt{hide1}(接近饱和)隐藏的信息为同样的字符串重复\texttt{50}倍。

                可以看到随着信息隐藏量的增加，\textbf{方法一的效果急剧下降}。

                \textbf{方法二}虽然在\texttt{PSNR}和压缩比方面不输于\textbf{方法三}(这可能得益于\textbf{\texttt{magic}函数加密})，但由于加密过程可能\textbf{增加突兀的高频分量}，因此肉眼较容易察觉。

                \textbf{方法三各方面性能较为均衡，不足的是信息容纳量略低。}

        \end{enumerate}

    % section 信息隐藏 (end)

    \newpage
    \section{人脸检测} % (fold)
    \label{sec:人脸检测}

        \begin{enumerate}
            \item 所给资料\href{../resource/Faces}{\texttt{Faces}}目录下包含从网图中截取的\texttt{31}张人脸，以其作为样本训练人脸标准\textbf{v}。

                \begin{enumerate}
                    \item 样本人脸大小不一，是否需要首先将图像调整为相同大小？

                        \textbf{不需要。}因为区域特征表现为\textbf{各颜色占给定区域的比例}，区域的大小不影响颜色比例。

                    \item 假设$L$分别取\texttt{3,4,5}，所得三个\textbf{v}之间有何关系？

                        取颜色种数$M=2^{3\times L}$，则特征向量

                        \begin{equation}
                            \mathbf{u}(R)=\left[f_0(R),f_1(R),\cdots,f_{M-1}(R)\right]^\text{T}
                        \end{equation}

                        其中
                        \[
                            \begin{matrix*}[l]
                                f_n(R) &= \frac{\sum_{(x,y)\in R} \delta (P_{x,y}-c(n))}{\sum_{(x,y)\in R}1} \\

                                P_{x,y} &= \left[ R_{x,y}^{(8\sim 9-L)}, G_{x,y}^{(8\sim 9-L)}, B_{x,y}^{(8\sim 9-L)} \right] \\

                                c(n) &= \left[ n^{(24\sim 25-L)}, n^{(16\sim 17-L)}, n^{(8\sim 9-L)} \right] \\
                            \end{matrix*}
                        \]

                        $L$越大，颜色划分越细致；$L$越小，颜色划分越粗略。
                        如取$L=4$，那么认为\texttt{RGB(0,0,0)}和\texttt{RGB(15,0,0)}是同一种颜色。

                        \begin{listing}[H]
                            \inputminted{matlab}{../imchar.m}
                            \caption{\texttt{imchar.m}}
                        \end{listing}

                        \begin{listing}[H]
                            \inputminted{matlab}{../train.m}
                            \caption{\texttt{train.m}}
                        \end{listing}

                        颜色种数为$2^{3\times L}$时，记训练得到的标准特征为$\mathbf{v}_L$

                        \begin{minted}{matlab}
>> D = dir('resource\Faces\*.bmp');
>> for i = 1:length(D)
set{i} = imread(['resource\Faces\',D(i).name]);
end
>> v3 = train(set,3);
>> v4 = train(set,4);
>> v5 = train(set,5);
                        \end{minted}

                        \begin{figure}[H]
                            \centering
                            \includegraphics[width=\textwidth]{v}
                            \caption{人脸标准特征(经过拉伸变换使得横轴一致方便展示)}
                        \end{figure}

                        包络相似，$L=5$的颜色分布信息更具体。

                        $\mathbf{v}_{L-1}$可由$\mathbf{v}_L$导出，具体索引对应关系比较繁琐，例如：

                        \begin{minted}{matlab}
>> v3(1)

ans =

    0.0150

>> sum(v4([1,2,17,18,257,258,273,274]))

ans =

    0.0150

>> v3(2)

ans =

   1.2379e-04

>> sum(v4([1,2,17,18,257,258,273,274]+2))

ans =

   1.2379e-04
                        \end{minted}

                \end{enumerate}

            \item 设计一种从任意大小的图片中检测任意多张人脸的算法并编程实现(输出图像在判定人脸的位置加上\textcolor{red}{红色的框})。随意选取一张多人照片，对程序进行测试。尝试$L$分别取不同的值，评价检测结果有何区别。

                由于人脸可能出现在图片的任何位置，而识别人脸的第一步是\textbf{固定区域}$R$，再计算待检测特征与标准特征的距离。

                为了方便，我们人为地规定区域$R$是矩形或正方形，但其具体尺寸仍不确定，因为这显然与图片尺寸、拍摄角度、拍摄距离等诸多因素相关。

                采用以下算法思路粗略地解决这个问题：

                \begin{enumerate}
                    \item 将图片划分为若干个小块(例如尺寸为$20\times 20$)，以较高的阈值$\epsilon_1$进行粗略人脸识别，筛选出符合条件的小块；
                    \item 将符合条件的相邻小块合并成一个矩形；
                    \item 将上一步得到的矩形在各自邻域进行扩展，若待检测区域的特征与标准特征的距离减小了，则保留扩展后的区域，否则舍弃这步扩展；
                    \item 将所有区域按左下右上四个方向依次尽力扩展一轮后，以较低的阈值$\epsilon_2$再次进行匹配，得到最终识别出的人脸。
                \end{enumerate}

                \inputminted{matlab}{../face_detect.m}
                \begingroup
                    \captionof{listing}{\texttt{face\_detect.m}}
                \endgroup

                经过参数的调试，结果如下表

                \begin{table}[H]
                    \caption{不同参数对人脸识别效果的影响}
                    \centering
                
                    \begin{tabular}{|c|c|c|c|c|c|c|}
                    \hline
                
                    \hline
                    \textbf{$L$} & \textbf{小块尺寸} & \textbf{$\epsilon_1$} & \textbf{$\epsilon_2$} & \textbf{识别结果} & 人脸识别率 & 识别错误率 \\
                    \hline
                        3 & 20 & 0.28 & 0.18 & 图\ref{fig:face3} & 100\% & 18.75\% \\
                    \hline
                        4 & 20 & 0.359 & 0.3 & 图\ref{fig:face4} & 83.33\% & 15.38\% \\
                    \hline
                        5 & 20 & 0.55 & 0.48 & 图\ref{fig:face5} & 75.00\% & 15.38\% \\
                    \hline
                
                    \hline
                    \end{tabular}
                \end{table}

                \begin{figure}[H]
                    \centering
                    \includegraphics[width=0.8\textwidth]{photo_face3}
                    \caption{$L=3$最佳参数识别结果}
                    \label{fig:face3}
                \end{figure}

                \begin{figure}[H]
                    \centering
                    \includegraphics[width=0.8\textwidth]{photo_face4}
                    \caption{$L=4$最佳参数识别结果}
                    \label{fig:face4}
                \end{figure}

                \begin{figure}[H]
                    \centering
                    \includegraphics[width=0.8\textwidth]{photo_face5}
                    \caption{$L=5$最佳参数识别结果}
                    \label{fig:face5}
                \end{figure}

                \textbf{分析：}

                从各种参数的测试可以明显看出\textbf{基于颜色的人脸识别}的缺陷：难以将其他部位的裸露皮肤与人脸精准地区分开。可以通过优化\textbf{扩展算法}、调整参数等手段在一定程度上优化结果，但并不能根治。

                \textbf{扩展算法的缺陷：}扩展顺序对结果有影响。当前算法是先尽力向左扩展，再尽力向下扩展、向右，最终尽力向上扩展。\textbf{改变扩展顺序}可能改善识别结果，可以考虑的改进是\textbf{每次扩展时选择距离缩小量最大的方向进行扩展}，听起来十分合理。

                再来看当前算法下不同参数对结果的影响，出乎意料的是，特征向量的颜色种数并不是越多越好(这应该与具体算法实现以及其他参数有很大关系，\textbf{我还是相信颜色数量越多结果越好})，$L$的增大使得我们不得不\textbf{放宽两级阈值的限制}以达到更好的识别效果。

                小块尺寸对结果的影响也很大，规律难以捉摸，没有体现在表中。

            \item 对上述图像分别进行如下处理后，再进行识别。(取$L=3$)

                \begin{enumerate}
                    \item 顺时针旋转\texttt{90}度(\texttt{imrotate})

                        \begin{figure}[H]
                            \centering
                            \includegraphics[width=0.8\textwidth]{photo_rotate}
                            \caption{旋转后识别结果}
                        \end{figure}

                        理论上旋转对结果应当没有影响，但当前扩展算法的实现是和方向有关的，因此结果稍有变化，有一张脸没能检出。

                    \item 保持高度不变，宽度拉伸为原来的\texttt{2}倍(\texttt{imresize})

                        \begin{figure}[H]
                            \centering
                            \includegraphics[width=0.8\textwidth]{photo_scale}
                            \caption{拉伸后识别结果}
                        \end{figure}

                        拉伸不但没有降低识别结果，反而检出了藏在人群后面的半张脸，这可能是由于拉伸后原来\texttt{20}的小块尺寸相当于变小了，提高了检出率。

                    \item 适当改变颜色(\texttt{imadjust})

                        可以预见这应当是一场灾难。

                        直接使用\texttt{help imadjust}中的示例参数

                        \begin{minted}{matlab}
>> image = face_detect(imadjust(photo,[.2 .3 0; .6 .7 1],[]),3,v3,20,0.28,0.18);
>> image = face_detect(imadjust(photo6,[.2 .3 0; .6 .7 1],[]),3,v3,20,0.6,0.6);
                        \end{minted}

                        不调整人脸检测算法参数是不可能识别出东西的，调整后终于也能识别，只不过识别出来的并没有一张人脸。

                        \begin{figure}[H]
                            \centering
                            \includegraphics[width=0.8\textwidth]{photo_adjust}
                            \caption{适当改变颜色后识别结果}
                        \end{figure}

                        基于颜色的人脸识别对色彩变化的灵敏度极高，稍有变化即可能对结果产生巨大影响。

                \end{enumerate}

            \item 如果可以重新选择人脸样本训练标准，我认为可以从以下几个方面考虑：

                \begin{enumerate}
                    \item 明确要识别的人种肤色，由此针对性地选取训练集；
                    \item 多增加一些戴眼镜(边框明显的眼镜)样本进行训练；
                    \item 当前提供的训练集似乎男女比例失衡严重，应当尽量选取比例均衡的训练集，虽然这可能对结果影响不大；
                    \item 考虑将头发纳入脸部特征，这样可能可以提高该算法对人脸和皮肤的区分度，不过可能对光头或脱发人群不友好。
                \end{enumerate}

        \end{enumerate}
    
    % section 人脸检测 (end)

    \newpage
    \section{实验收获与总结} % (fold)
    \label{sec:实验收获与总结}
    
        \begin{itemize}
            \item \LaTeX{}熟练度提升飞速；
            \item 学习到了\texttt{meshgrid}这个神奇的函数，在高维矩阵索引时挺有用的，避免了繁杂冗余且低效的\textbf{循环}，\texttt{MATLAB}友好型代码；
            \item 一直以为\texttt{MATLAB}中没有像\texttt{python}那样的元素遍历\texttt{for element in list}方法，后来一查发现竟然也有元素遍历\texttt{for ve = v}，不过这是最后才发现的，没来得及用上；
            \item \texttt{mat2cell}以及\texttt{cell2mat}灵活转换，极大减少某些矩阵操作的代码量，但矩阵过大时，\texttt{mat2cell}的效率似乎会急剧下降；
            \item 尽量不要把\texttt{load}等文件读取操作放在函数体里执行，这样会大幅降低函数运行效率；
            \item 粗略了解了\texttt{JPEG}编解码原理；
            \item 粗略掌握了在\texttt{DCT}域隐藏少量信息的方法，可以表白用(但表白对象仅限电子系大二以上学生)；
            \item \texttt{DCT}域隐藏信息时使用\texttt{magic(10)}加密索引号，增加了隐蔽性；
            \item 将二进制信息隐藏在可能是负数的系数最低位时不必机械地将负数用补码表示，从奇偶性入手，编解码都方便；
            \item 人脸识别的实现感觉比较失败，算法没有经过充分的优化(而且有大段重复的代码，没有很好的复用，风格不佳)，参数也似乎没有调试至最佳状态，算法的具体优化办法在相应部分已经陈述过，不再赘述；
            \item 基于颜色和形状特征的人脸识别应该可以有效地区分人脸和其他皮肤。
        \end{itemize}

    % section 实验收获与总结 (end)

\end{document}